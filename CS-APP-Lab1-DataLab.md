---
title: 'CS:APP Lab1: DataLab'
date: 2021-07-28 21:06:15
update: 2021-07-28 21:06:15
tags:
    - CS:APP
    - 位运算
categories: 题解类
---

# 0x00 简介

一直在学习CS:APP这本书，本以为大名鼎鼎的Lab会出现在书本上，没想到一直看到第三章也没看见。在网上查了以下才知道是在线的。想想也十分合理，毕竟可能会经常有更新。这里就记录完成第一个Lab——DataLab的过程。

DataLab是使用受限的C语言运算子集来实现逻辑运算/补码运算/浮点运算的函数，例如，可能会要求仅使用位级运算和线性的过程来实现求绝对值的函数。这个Lab可以帮助理解C数据类型的位级表示和数据操作的位级行为。

<!--more-->

## 要求

这个Lab主要是在一个C语言文件中实现函数，在实现时对于使用的运算种类和数量都有严格的要求。同时Lab提供了一组工具用于检查代码中使用的运算是否符合要求以及用于测试代码正确与否。还提供了一个小工具可以打印整形数据和浮点数据的16进制或10禁止表示。

具体的编码要求附在文末，同时每道题可能还有自己的更加严格的要求。

## 概览

总共有不同分值的整数和浮点数函数共13个：

| 函数             | 描述                     | 分值 |
| ---------------- | ------------------------ | ---- |
| `bitXor`         | 计算异或                 | 1    |
| `tmin`           | 返回最小补码值           | 1    |
| `isTmax`         | 判断是否最大补码值       | 2    |
| `allOddBits`     | 判断是否奇数位置都为1    | 2    |
| `negate`         | 求相反数                 | 2    |
| `isAsciiDigit`   | 判断是否Ascii数字        | 3    |
| `conditional`    | 实现条件分支             | 3    |
| `isLessOrEqual`  | 实现小于等于             | 3    |
| `logicalNeg`     | 实现逻辑非(!)            | 4    |
| `howManyBits`    | 计算能表达数据的最小长度 | 4    |
| `floatScale2`    | 实现位级浮点数*2         | 4    |
| `floatFloat2Int` | 实现位级float转int       | 4    |
| `floatPower2`    | 实现位级2.0^x            | 4    |

# 0x01 bitXor

第一道题目：
```C
/* 
 * bitXor - x^y using only ~ and & 
 *   Example: bitXor(4, 5) = 1
 *   Legal ops: ~ &
 *   Max ops: 14
 *   Rating: 1
 */
int bitXor(int x, int y) {
  return 2;
}
```

只使用 ~ 和 & 运算符实现 ^ 运算。最多可以使用14个运算符。

考虑位级异或运算的真值表：

| `x` | `y` | `x ^ y` |
| --- | --- | ------- |
| `0` | `0` | `0`     |
| `0` | `1` | `1`     |
| `1` | `0` | `1`     |
| `1` | `1` | `0`     |

可以看到令 `x ^ y = 1` 的情况分别是 `x = 0, y = 1` 和 `x = 1, y = 0`，根据卡诺图化简的方法和逻辑代数的表达方式，这个真值表可以化简为：`X'Y + XY'`，即：`x ^ y = (x & ~y) | (~x & y)`。

由于题目要求只能使用 `&` 和 `~`，消去上式中的 `|`：

```
(x & ~y) | (~x & y)
= ~~((x & ~y) | (~x & y))
= ~((~x | y) & (x | ~y))
= ~(~~(~x | y) & ~~(x | ~y))
= ~(~(x & ~y) & ~(~x & y))
```

因此直接将上面的 `return 2` 改成 `return ~(~(x & ~y) & ~(~x & y))` 即可。